varnishtest "basic req sanity checks"

feature cmd jq

varnish v1 -vcl {
	import std;

	backend be none;
	sub vcl_recv {
		unset req.http.baz;
		set req.http.bar = "qux";
		set req.http.x = "1";
		std.log("in recv");
		return (synth(200));
	}

	sub vcl_synth {
		std.log("in synth");
		set resp.http.y = "ignored";
		unset resp.http.y;
		set resp.http.z = "will be overridden";
		set resp.http.z = "will be overridden too";
		set resp.http.z = "final";
	}
} -start

client c1 {
	txreq -url "/foo" -hdr "bar: baz" -hdr "bar: qux" -hdr "bar: quxx" \
	    -hdr "Cookie: chocolate" -hdr "Cookie: hazelnut"
	rxresp
} -run

# give some time for the logs to land (0.1s is overly generous)
delay 0.1

shell {
	t() {
		if [ "$(varnishlog-json -c -n ${v1_name} -d | jq -r $1)" = "$2" ]; then
			echo "ok: $1 == $2"
		else
			echo "fail: $1 ($(varnishlog-json -c -n ${v1_name} -d | jq -r $1)) != $2"
			exit 1
		fi
	}

	varnishlog-json -c -n ${v1_name} -d
	varnishlog-json -c -n ${v1_name} -d | jq >${tmpdir}/varnishlog-json-001.out

	t .req.url /foo
	t .req.method GET
	t .req.proto HTTP/1.1
	t .req.headers.bar baz,qux,quxx
	t .req.headers.x "null"
	t .req.headers.host 127.0.0.1
	t .req.headers.cookie "chocolate;hazelnut"

	t .resp.status 200
	t .resp.reason OK
	t .resp.proto HTTP/1.1
	t .resp.headers.y "null"
	t .resp.headers.z "final"

	t .side client
	t .id 1001
	t .client.rAddr 127.0.0.1
	t .client.sock a0

	t .logs[0] "in recv"
	t .logs[1] "in synth"
}
